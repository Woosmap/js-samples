<!DOCTYPE html>
<html>
  <head>
    <title>Map Clustering with Stores</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8" />

    <script type="module" crossorigin>
      (function () {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
          s(r);
        new MutationObserver((r) => {
          for (const n of r)
            if (n.type === "childList")
              for (const c of n.addedNodes)
                c.tagName === "LINK" && c.rel === "modulepreload" && s(c);
        }).observe(document, { childList: !0, subtree: !0 });
        function e(r) {
          const n = {};
          return (
            r.integrity && (n.integrity = r.integrity),
            r.referrerPolicy && (n.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === "use-credentials"
              ? (n.credentials = "include")
              : r.crossOrigin === "anonymous"
                ? (n.credentials = "omit")
                : (n.credentials = "same-origin"),
            n
          );
        }
        function s(r) {
          if (r.ep) return;
          r.ep = !0;
          const n = e(r);
          fetch(r.href, n);
        }
      })();
      const z = [
          Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
        ],
        Z = 1,
        P = 8;
      class D {
        static from(t) {
          if (!(t instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [e, s] = new Uint8Array(t, 0, 2);
          if (e !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const r = s >> 4;
          if (r !== Z) throw new Error(`Got v${r} data when expected v${Z}.`);
          const n = z[s & 15];
          if (!n) throw new Error("Unrecognized array type.");
          const [c] = new Uint16Array(t, 2, 1),
            [l] = new Uint32Array(t, 4, 1);
          return new D(l, c, n, t);
        }
        constructor(t, e = 64, s = Float64Array, r) {
          if (isNaN(t) || t < 0)
            throw new Error(`Unpexpected numItems value: ${t}.`);
          ((this.numItems = +t),
            (this.nodeSize = Math.min(Math.max(+e, 2), 65535)),
            (this.ArrayType = s),
            (this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array));
          const n = z.indexOf(this.ArrayType),
            c = t * 2 * this.ArrayType.BYTES_PER_ELEMENT,
            l = t * this.IndexArrayType.BYTES_PER_ELEMENT,
            o = (8 - (l % 8)) % 8;
          if (n < 0) throw new Error(`Unexpected typed array class: ${s}.`);
          r && r instanceof ArrayBuffer
            ? ((this.data = r),
              (this.ids = new this.IndexArrayType(this.data, P, t)),
              (this.coords = new this.ArrayType(this.data, P + l + o, t * 2)),
              (this._pos = t * 2),
              (this._finished = !0))
            : ((this.data = new ArrayBuffer(P + c + l + o)),
              (this.ids = new this.IndexArrayType(this.data, P, t)),
              (this.coords = new this.ArrayType(this.data, P + l + o, t * 2)),
              (this._pos = 0),
              (this._finished = !1),
              new Uint8Array(this.data, 0, 2).set([219, (Z << 4) + n]),
              (new Uint16Array(this.data, 2, 1)[0] = e),
              (new Uint32Array(this.data, 4, 1)[0] = t));
        }
        add(t, e) {
          const s = this._pos >> 1;
          return (
            (this.ids[s] = s),
            (this.coords[this._pos++] = t),
            (this.coords[this._pos++] = e),
            s
          );
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems)
            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return (
            N(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
            (this._finished = !0),
            this
          );
        }
        range(t, e, s, r) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n, coords: c, nodeSize: l } = this,
            o = [0, n.length - 1, 0],
            h = [];
          for (; o.length; ) {
            const p = o.pop() || 0,
              a = o.pop() || 0,
              u = o.pop() || 0;
            if (a - u <= l) {
              for (let f = u; f <= a; f++) {
                const m = c[2 * f],
                  w = c[2 * f + 1];
                m >= t && m <= s && w >= e && w <= r && h.push(n[f]);
              }
              continue;
            }
            const d = (u + a) >> 1,
              y = c[2 * d],
              g = c[2 * d + 1];
            (y >= t && y <= s && g >= e && g <= r && h.push(n[d]),
              (p === 0 ? t <= y : e <= g) &&
                (o.push(u), o.push(d - 1), o.push(1 - p)),
              (p === 0 ? s >= y : r >= g) &&
                (o.push(d + 1), o.push(a), o.push(1 - p)));
          }
          return h;
        }
        within(t, e, s) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: r, coords: n, nodeSize: c } = this,
            l = [0, r.length - 1, 0],
            o = [],
            h = s * s;
          for (; l.length; ) {
            const p = l.pop() || 0,
              a = l.pop() || 0,
              u = l.pop() || 0;
            if (a - u <= c) {
              for (let f = u; f <= a; f++)
                k(n[2 * f], n[2 * f + 1], t, e) <= h && o.push(r[f]);
              continue;
            }
            const d = (u + a) >> 1,
              y = n[2 * d],
              g = n[2 * d + 1];
            (k(y, g, t, e) <= h && o.push(r[d]),
              (p === 0 ? t - s <= y : e - s <= g) &&
                (l.push(u), l.push(d - 1), l.push(1 - p)),
              (p === 0 ? t + s >= y : e + s >= g) &&
                (l.push(d + 1), l.push(a), l.push(1 - p)));
          }
          return o;
        }
      }
      function N(i, t, e, s, r, n) {
        if (r - s <= e) return;
        const c = (s + r) >> 1;
        (K(i, t, c, s, r, n),
          N(i, t, e, s, c - 1, 1 - n),
          N(i, t, e, c + 1, r, 1 - n));
      }
      function K(i, t, e, s, r, n) {
        for (; r > s; ) {
          if (r - s > 600) {
            const h = r - s + 1,
              p = e - s + 1,
              a = Math.log(h),
              u = 0.5 * Math.exp((2 * a) / 3),
              d =
                0.5 *
                Math.sqrt((a * u * (h - u)) / h) *
                (p - h / 2 < 0 ? -1 : 1),
              y = Math.max(s, Math.floor(e - (p * u) / h + d)),
              g = Math.min(r, Math.floor(e + ((h - p) * u) / h + d));
            K(i, t, e, y, g, n);
          }
          const c = t[2 * e + n];
          let l = s,
            o = r;
          for (b(i, t, s, e), t[2 * r + n] > c && b(i, t, s, r); l < o; ) {
            for (b(i, t, l, o), l++, o--; t[2 * l + n] < c; ) l++;
            for (; t[2 * o + n] > c; ) o--;
          }
          (t[2 * s + n] === c ? b(i, t, s, o) : (o++, b(i, t, o, r)),
            o <= e && (s = o + 1),
            e <= o && (r = o - 1));
        }
      }
      function b(i, t, e, s) {
        (F(i, e, s), F(t, 2 * e, 2 * s), F(t, 2 * e + 1, 2 * s + 1));
      }
      function F(i, t, e) {
        const s = i[t];
        ((i[t] = i[e]), (i[e] = s));
      }
      function k(i, t, e, s) {
        const r = i - e,
          n = t - s;
        return r * r + n * n;
      }
      const Y = {
          minZoom: 0,
          maxZoom: 16,
          minPoints: 2,
          radius: 40,
          extent: 512,
          nodeSize: 64,
          log: !1,
          generateId: !1,
          reduce: null,
          map: (i) => i,
        },
        W =
          Math.fround ||
          ((i) => (t) => ((i[0] = +t), i[0]))(new Float32Array(1)),
        A = 2,
        E = 3,
        C = 4,
        x = 5,
        G = 6;
      class Q {
        constructor(t) {
          ((this.options = Object.assign(Object.create(Y), t)),
            (this.trees = new Array(this.options.maxZoom + 1)),
            (this.stride = this.options.reduce ? 7 : 6),
            (this.clusterProps = []));
        }
        load(t) {
          const { log: e, minZoom: s, maxZoom: r } = this.options;
          e && console.time("total time");
          const n = `prepare ${t.length} points`;
          (e && console.time(n), (this.points = t));
          const c = [];
          for (let o = 0; o < t.length; o++) {
            const h = t[o];
            if (!h.geometry) continue;
            const [p, a] = h.geometry.coordinates,
              u = W(O(p)),
              d = W(S(a));
            (c.push(u, d, 1 / 0, o, -1, 1), this.options.reduce && c.push(0));
          }
          let l = (this.trees[r + 1] = this._createTree(c));
          e && console.timeEnd(n);
          for (let o = r; o >= s; o--) {
            const h = +Date.now();
            ((l = this.trees[o] = this._createTree(this._cluster(l, o))),
              e &&
                console.log(
                  "z%d: %d clusters in %dms",
                  o,
                  l.numItems,
                  +Date.now() - h,
                ));
          }
          return (e && console.timeEnd("total time"), this);
        }
        getClusters(t, e) {
          let s = ((((t[0] + 180) % 360) + 360) % 360) - 180;
          const r = Math.max(-90, Math.min(90, t[1]));
          let n =
            t[2] === 180 ? 180 : ((((t[2] + 180) % 360) + 360) % 360) - 180;
          const c = Math.max(-90, Math.min(90, t[3]));
          if (t[2] - t[0] >= 360) ((s = -180), (n = 180));
          else if (s > n) {
            const a = this.getClusters([s, r, 180, c], e),
              u = this.getClusters([-180, r, n, c], e);
            return a.concat(u);
          }
          const l = this.trees[this._limitZoom(e)],
            o = l.range(O(s), S(c), O(n), S(r)),
            h = l.data,
            p = [];
          for (const a of o) {
            const u = this.stride * a;
            p.push(
              h[u + x] > 1 ? H(h, u, this.clusterProps) : this.points[h[u + E]],
            );
          }
          return p;
        }
        getChildren(t) {
          const e = this._getOriginId(t),
            s = this._getOriginZoom(t),
            r = "No cluster with the specified id.",
            n = this.trees[s];
          if (!n) throw new Error(r);
          const c = n.data;
          if (e * this.stride >= c.length) throw new Error(r);
          const l =
              this.options.radius / (this.options.extent * Math.pow(2, s - 1)),
            o = c[e * this.stride],
            h = c[e * this.stride + 1],
            p = n.within(o, h, l),
            a = [];
          for (const u of p) {
            const d = u * this.stride;
            c[d + C] === t &&
              a.push(
                c[d + x] > 1
                  ? H(c, d, this.clusterProps)
                  : this.points[c[d + E]],
              );
          }
          if (a.length === 0) throw new Error(r);
          return a;
        }
        getLeaves(t, e, s) {
          ((e = e || 10), (s = s || 0));
          const r = [];
          return (this._appendLeaves(r, t, e, s, 0), r);
        }
        getTile(t, e, s) {
          const r = this.trees[this._limitZoom(t)],
            n = Math.pow(2, t),
            { extent: c, radius: l } = this.options,
            o = l / c,
            h = (s - o) / n,
            p = (s + 1 + o) / n,
            a = { features: [] };
          return (
            this._addTileFeatures(
              r.range((e - o) / n, h, (e + 1 + o) / n, p),
              r.data,
              e,
              s,
              n,
              a,
            ),
            e === 0 &&
              this._addTileFeatures(
                r.range(1 - o / n, h, 1, p),
                r.data,
                n,
                s,
                n,
                a,
              ),
            e === n - 1 &&
              this._addTileFeatures(
                r.range(0, h, o / n, p),
                r.data,
                -1,
                s,
                n,
                a,
              ),
            a.features.length ? a : null
          );
        }
        getClusterExpansionZoom(t) {
          let e = this._getOriginZoom(t) - 1;
          for (; e <= this.options.maxZoom; ) {
            const s = this.getChildren(t);
            if ((e++, s.length !== 1)) break;
            t = s[0].properties.cluster_id;
          }
          return e;
        }
        _appendLeaves(t, e, s, r, n) {
          const c = this.getChildren(e);
          for (const l of c) {
            const o = l.properties;
            if (
              (o && o.cluster
                ? n + o.point_count <= r
                  ? (n += o.point_count)
                  : (n = this._appendLeaves(t, o.cluster_id, s, r, n))
                : n < r
                  ? n++
                  : t.push(l),
              t.length === s)
            )
              break;
          }
          return n;
        }
        _createTree(t) {
          const e = new D(
            (t.length / this.stride) | 0,
            this.options.nodeSize,
            Float32Array,
          );
          for (let s = 0; s < t.length; s += this.stride) e.add(t[s], t[s + 1]);
          return (e.finish(), (e.data = t), e);
        }
        _addTileFeatures(t, e, s, r, n, c) {
          for (const l of t) {
            const o = l * this.stride,
              h = e[o + x] > 1;
            let p, a, u;
            if (h)
              ((p = J(e, o, this.clusterProps)), (a = e[o]), (u = e[o + 1]));
            else {
              const g = this.points[e[o + E]];
              p = g.properties;
              const [f, m] = g.geometry.coordinates;
              ((a = O(f)), (u = S(m)));
            }
            const d = {
              type: 1,
              geometry: [
                [
                  Math.round(this.options.extent * (a * n - s)),
                  Math.round(this.options.extent * (u * n - r)),
                ],
              ],
              tags: p,
            };
            let y;
            (h || this.options.generateId
              ? (y = e[o + E])
              : (y = this.points[e[o + E]].id),
              y !== void 0 && (d.id = y),
              c.features.push(d));
          }
        }
        _limitZoom(t) {
          return Math.max(
            this.options.minZoom,
            Math.min(Math.floor(+t), this.options.maxZoom + 1),
          );
        }
        _cluster(t, e) {
          const {
              radius: s,
              extent: r,
              reduce: n,
              minPoints: c,
            } = this.options,
            l = s / (r * Math.pow(2, e)),
            o = t.data,
            h = [],
            p = this.stride;
          for (let a = 0; a < o.length; a += p) {
            if (o[a + A] <= e) continue;
            o[a + A] = e;
            const u = o[a],
              d = o[a + 1],
              y = t.within(o[a], o[a + 1], l),
              g = o[a + x];
            let f = g;
            for (const m of y) {
              const w = m * p;
              o[w + A] > e && (f += o[w + x]);
            }
            if (f > g && f >= c) {
              let m = u * g,
                w = d * g,
                T,
                R = -1;
              const L = (((a / p) | 0) << 5) + (e + 1) + this.points.length;
              for (const V of y) {
                const M = V * p;
                if (o[M + A] <= e) continue;
                o[M + A] = e;
                const j = o[M + x];
                ((m += o[M] * j),
                  (w += o[M + 1] * j),
                  (o[M + C] = L),
                  n &&
                    (T ||
                      ((T = this._map(o, a, !0)),
                      (R = this.clusterProps.length),
                      this.clusterProps.push(T)),
                    n(T, this._map(o, M))));
              }
              ((o[a + C] = L),
                h.push(m / f, w / f, 1 / 0, L, -1, f),
                n && h.push(R));
            } else {
              for (let m = 0; m < p; m++) h.push(o[a + m]);
              if (f > 1)
                for (const m of y) {
                  const w = m * p;
                  if (!(o[w + A] <= e)) {
                    o[w + A] = e;
                    for (let T = 0; T < p; T++) h.push(o[w + T]);
                  }
                }
            }
          }
          return h;
        }
        _getOriginId(t) {
          return (t - this.points.length) >> 5;
        }
        _getOriginZoom(t) {
          return (t - this.points.length) % 32;
        }
        _map(t, e, s) {
          if (t[e + x] > 1) {
            const c = this.clusterProps[t[e + G]];
            return s ? Object.assign({}, c) : c;
          }
          const r = this.points[t[e + E]].properties,
            n = this.options.map(r);
          return s && n === r ? Object.assign({}, n) : n;
        }
      }
      function H(i, t, e) {
        return {
          type: "Feature",
          id: i[t + E],
          properties: J(i, t, e),
          geometry: { type: "Point", coordinates: [q(i[t]), X(i[t + 1])] },
        };
      }
      function J(i, t, e) {
        const s = i[t + x],
          r =
            s >= 1e4
              ? `${Math.round(s / 1e3)}k`
              : s >= 1e3
                ? `${Math.round(s / 100) / 10}k`
                : s,
          n = i[t + G],
          c = n === -1 ? {} : Object.assign({}, e[n]);
        return Object.assign(c, {
          cluster: !0,
          cluster_id: i[t + E],
          point_count: s,
          point_count_abbreviated: r,
        });
      }
      function O(i) {
        return i / 360 + 0.5;
      }
      function S(i) {
        const t = Math.sin((i * Math.PI) / 180),
          e = 0.5 - (0.25 * Math.log((1 + t) / (1 - t))) / Math.PI;
        return e < 0 ? 0 : e > 1 ? 1 : e;
      }
      function q(i) {
        return (i - 0.5) * 360;
      }
      function X(i) {
        const t = ((180 - i * 360) * Math.PI) / 180;
        return (360 * Math.atan(Math.exp(t))) / Math.PI - 90;
      }
      let _,
        I,
        $,
        B = [];
      const tt = "https://images.woosmap.com/dot-green.svg",
        et = { radius: 30, extent: 256, maxZoom: 15, minPoints: 2 };
      function st() {
        ((I = new woosmap.map.InfoWindow({})),
          (_ = new window.woosmap.map.Map(document.getElementById("map"), {
            center: { lat: 53.3485, lng: -6.257 },
            zoom: 12,
            styles: [
              { elementType: "geometry", stylers: [{ color: "#f6f6f6" }] },
              { elementType: "labels.icon", stylers: [{ visibility: "off" }] },
              {
                elementType: "labels.text.fill",
                stylers: [{ color: "#616161" }],
              },
              {
                elementType: "labels.text.stroke",
                stylers: [{ color: "#f5f5f5" }],
              },
              {
                featureType: "administrative.land_parcel",
                elementType: "labels.text.fill",
                stylers: [{ color: "#bdbdbd" }],
              },
              {
                featureType: "road",
                elementType: "geometry",
                stylers: [{ color: "#ffffff" }],
              },
              {
                featureType: "road.arterial",
                elementType: "labels.text.fill",
                stylers: [{ color: "#757575" }],
              },
              {
                featureType: "road.highway",
                elementType: "geometry",
                stylers: [{ color: "#dadada" }],
              },
              {
                featureType: "road.highway",
                elementType: "labels.text.fill",
                stylers: [{ color: "#616161" }],
              },
              {
                featureType: "road.local",
                elementType: "labels.text.fill",
                stylers: [{ color: "#9e9e9e" }],
              },
              {
                featureType: "transit.line",
                elementType: "geometry",
                stylers: [{ color: "#e5e5e5" }],
              },
              {
                featureType: "transit.station",
                elementType: "geometry",
                stylers: [{ color: "#eeeeee" }],
              },
              {
                featureType: "water",
                elementType: "geometry",
                stylers: [{ color: "#c9c9c9" }],
              },
              {
                featureType: "water",
                elementType: "labels.text.fill",
                stylers: [{ color: "#9e9e9e" }],
              },
            ],
          })),
          nt().then((i) => {
            (($ = new Q(et).load(i)), v());
          }),
          ot());
      }
      function nt() {
        const i = [],
          t = { storesByPage: 300 },
          e = new woosmap.map.StoresService(),
          s = async (r) => (
            r && (t.page = r),
            e
              .search(t)
              .then(
                (n) => (
                  i.push(...n.features),
                  t.page === n.pagination.pageCount
                    ? i
                    : s(n.pagination.page + 1)
                ),
              )
              .catch((n) => {
                throw (
                  console.error(n),
                  new Error(`Error getting all stores: ${n.message}`)
                );
              })
          );
        return s();
      }
      function ot() {
        (_.addListener("dragend", U(v, 20)),
          _.addListener("zoom_changed", U(v, 20)),
          window.addEventListener("resize", U(v, 100)));
      }
      function v() {
        rt();
        const i = _.getBounds(),
          t = [
            i.getSouthWest().lng(),
            i.getSouthWest().lat(),
            i.getNorthEast().lng(),
            i.getNorthEast().lat(),
          ],
          e = $.getClusters(t, _.getZoom());
        for (const s of e) {
          const r = {
            lat: s.geometry.coordinates[1],
            lng: s.geometry.coordinates[0],
          };
          B.push(it(s, r));
        }
      }
      function rt() {
        for (const i of B) i.setMap(null);
        B = [];
      }
      function it(i, t) {
        return i.properties.cluster ? ct(i, t) : at(i, t);
      }
      function ct(i, t) {
        const e = i.properties.point_count,
          s = e < 5 ? "#0B9D58" : e < 12 ? "#F5B300" : "#DA0A40",
          r = e < 80 ? 45 : e < 400 ? 55 : 65,
          n = window.btoa(`
<svg fill="${s}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
  <circle cx="120" cy="120" opacity=".8" r="70" />
  <circle cx="120" cy="120" opacity=".3" r="80" />
  <circle cx="120" cy="120" opacity=".2" r="110" />
</svg>`),
          c = new window.woosmap.map.Marker({
            label: {
              text: i.properties.point_count_abbreviated,
              color: "white",
            },
            position: t,
            icon: {
              url: `data:image/svg+xml;base64,${n}`,
              scaledSize: new window.woosmap.map.Size(r, r),
            },
            map: _,
          });
        return (
          c.addListener("click", (l) => {
            I.close();
            const o = $.getClusterExpansionZoom(i.properties.cluster_id);
            (_.setCenter(c.getPosition()), _.setZoom(o));
          }),
          c
        );
      }
      function at(i, t) {
        const e = new window.woosmap.map.Marker({
          icon: { url: tt, scaledSize: { height: 20, width: 20 } },
          position: t,
          map: _,
        });
        return (
          e.addListener("click", () => {
            (I.setContent(`<h3>${i.properties.name}</h3>`), I.open(_, e));
          }),
          e
        );
      }
      function U(i, t) {
        let e;
        return (...s) => {
          (clearTimeout(e),
            (e = setTimeout(() => {
              i(...s);
            }, t)));
        };
      }
      window.initMap = st;
    </script>
    <style>
      #map {
        height: 100%;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          Segoe UI,
          Roboto,
          Helvetica Neue,
          Arial,
          Noto Sans,
          sans-serif,
          Apple Color Emoji,
          Segoe UI Emoji,
          Segoe UI Symbol,
          Noto Color Emoji;
      }
    </style>
  </head>
  <body>
    <!--The div element for the map -->
    <div id="map"></div>

    <script
      src="https://sdk.woosmap.com/map/map.js?key=woos-3cad58f4-0d94-3f95-8fa3-1f0dc035591c&callback=initMap"
      defer
    ></script>
  </body>
</html>
